<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Zajno 3D Text Animation with Bullets</title>
    <style>
      body {
        margin: 0;
        background: radial-gradient(#111, #000);
        overflow: hidden;
        color: white;
        font-family: sans-serif;
        text-align: center;
      }
      canvas {
        display: block;
      }
      #info {
        position: absolute;
        top: 20px;
        width: 100%;
        pointer-events: none;
        text-shadow: 1px 1px 2px black;
      }
      #info h1 {
        font-weight: 300;
        margin: 0;
      }
      #info p {
        margin: 5px 0 0;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <h1>Zajno</h1>
      <p>Click to fire at the letters! Drag to rotate the view.</p>
    </div>

    <!-- Importmap for modern module loading -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/"
        }
      }
    </script>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { FontLoader } from "three/addons/loaders/FontLoader.js";
      import { TextGeometry } from "three/addons/geometries/TextGeometry.js";

      let scene, camera, renderer, controls;
      let letters = [];
      let bullets = [];
      const textString = "Zajno";
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      init();
      animate();

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 30);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(0, 20, 20);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x666666));

        const loader = new FontLoader();
        loader.load(
          "https://threejs.org/examples/fonts/helvetiker_bold.typeface.json",
          function (font) {
            const material = new THREE.MeshPhongMaterial({
              color: 0xffffff,
              flatShading: true,
            });

            let offsetX = -10;
            for (let i = 0; i < textString.length; i++) {
              const letterGeo = new TextGeometry(textString[i], {
                font: font,
                size: 5,
                height: 1,
                curveSegments: 12,
                bevelEnabled: false,
              });
              letterGeo.center();
              const mesh = new THREE.Mesh(letterGeo, material);
              mesh.position.x = offsetX;
              scene.add(mesh);
              letters.push({
                mesh: mesh,
                originalColor: material.color.clone(),
                speed: Math.random() * 0.02 + 0.01,
                rotSpeed: (Math.random() - 0.5) * 0.02,
                floatAmp: Math.random() * 0.5 + 0.5,
                phase: Math.random() * Math.PI * 2,
              });
              offsetX += 5.5;
            }
          }
        );

        window.addEventListener("resize", onWindowResize);
        window.addEventListener("click", onDocumentClick, false);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentClick(event) {
        // Calculate mouse position in normalized device coordinates (-1 to +1)
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Set up a raycaster from the camera to the mouse position
        raycaster.setFromCamera(mouse, camera);

        // Create a small bullet and add it to the scene
        const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
        bullet.position.copy(camera.position);
        scene.add(bullet);

        // Get the direction the bullet should travel
        const direction = new THREE.Vector3();
        raycaster.ray.direction.normalize();
        direction.copy(raycaster.ray.direction);

        bullets.push({ mesh: bullet, direction: direction });
      }

      function animate() {
        requestAnimationFrame(animate);

        const t = Date.now() * 0.002;
        letters.forEach((obj) => {
          obj.mesh.rotation.y += obj.rotSpeed;
          obj.mesh.position.y =
            Math.sin(t * obj.speed + obj.phase) * obj.floatAmp;
          obj.mesh.rotation.x = Math.cos(t * obj.speed + obj.phase) * 0.2;
          obj.mesh.scale.setScalar(
            1 + Math.sin(t * obj.speed + obj.phase) * 0.05
          );
        });

        // Update and check bullets
        bullets.forEach((bullet, index) => {
          // Move bullet
          bullet.mesh.position.addScaledVector(bullet.direction, 0.5);

          // Check for collision with letters
          letters.forEach((letter) => {
            if (bullet.mesh.position.distanceTo(letter.mesh.position) < 2) {
              // Impact effect: change color and push the letter
              letter.mesh.material.color.set(0xff0000);
              setTimeout(
                () => letter.mesh.material.color.copy(letter.originalColor),
                200
              );

              // Push the letter back slightly
              const pushDirection = bullet.mesh.position
                .clone()
                .sub(letter.mesh.position)
                .normalize()
                .multiplyScalar(-0.5);
              letter.mesh.position.add(pushDirection);

              // Remove bullet
              scene.remove(bullet.mesh);
              bullets.splice(index, 1);
            }
          });

          // Remove bullet if it goes too far
          if (bullet.mesh.position.length() > 50) {
            scene.remove(bullet.mesh);
            bullets.splice(index, 1);
          }
        });

        controls.update();
        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
